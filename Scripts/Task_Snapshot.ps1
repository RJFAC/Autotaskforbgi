<#
.SYNOPSIS
    AutoTask Snapshot Tool V2.8
    用於打包所有腳本、設定檔與最近日誌，供 AI 進行除錯分析。
    V2.8 新增: 全設定檔合併機制 (All_Configs_Combined.txt)，防止檔案過多。
    V2.7 新增: 自動匯出 Windows 排程器 (Task Scheduler) 設定檔 XML。
    V2.6 新增: All_Source_Combined.txt 機制，不再複製個別 ps1/bat。
#>

$SnapshotVersion = "V2.8"
$SourceDir = "C:\AutoTask"
$OutputDir = "C:\AutoTask_Snapshots"
$Timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
$ZipName = "AutoTask_Snapshot_$Timestamp.zip"
$ZipPath = Join-Path $OutputDir $ZipName

# 建立暫存目錄結構
$TempDir = Join-Path $OutputDir "Temp_$Timestamp"
$TempSource = Join-Path $TempDir "1_Source_Code"
$TempConfigs = Join-Path $TempDir "2_Configs"
$TempLogs = Join-Path $TempDir "3_Logs_Summary"

New-Item -ItemType Directory -Path $TempSource -Force | Out-Null
New-Item -ItemType Directory -Path $TempConfigs -Force | Out-Null
New-Item -ItemType Directory -Path $TempLogs -Force | Out-Null

Write-Host "=== AutoTask Snapshot Tool $SnapshotVersion ===" -ForegroundColor Cyan
Write-Host "正在準備快照包..."

# ==============================================================================
# 1. 原始碼合併 (Source Code Combination)
# ==============================================================================
Write-Host " -> 1/4 正在合併原始碼..."
$CombinedSourceFile = Join-Path $TempSource "All_Source_Combined.txt"

$SourceHeader = "=== [ AutoTask Full Source Code Dump ] ===`r`n`r`n" +
                "Generated by Task_Snapshot $SnapshotVersion`r`n`r`n" +
                "此檔案包含所有 .bat 與 .ps1 的完整內容，供 AI 一次性讀取。`r`n`r`n"
Set-Content -Path $CombinedSourceFile -Value $SourceHeader -Encoding UTF8

$SourceFiles = @()
$SourceFiles += Get-ChildItem -Path $SourceDir -Filter "*.bat" -File
$SourceFiles += Get-ChildItem -Path "$SourceDir\Scripts" -Filter "*.ps1" -File

foreach ($File in $SourceFiles) {
    $FileBlock = "`r`n######################################################################`r`n" +
                 "FILE: $($File.Name)`r`n" +
                 "PATH: $($File.FullName)`r`n" +
                 "######################################################################`r`n`r`n"
    Add-Content -Path $CombinedSourceFile -Value $FileBlock -Encoding UTF8
    
    # 讀取內容並附加
    if (Test-Path $File.FullName) {
        $Content = Get-Content -Path $File.FullName -Raw
        Add-Content -Path $CombinedSourceFile -Value $Content -Encoding UTF8
    }
}

# ==============================================================================
# 2. 設定檔與排程器合併 (Configs & Tasks Combination)
# ==============================================================================
Write-Host " -> 2/4 正在合併設定檔與排程器..."
$CombinedConfigFile = Join-Path $TempConfigs "All_Configs_Combined.txt"

$ConfigHeader = "=== [ AutoTask Configs & Scheduler Dump ] ===`r`n`r`n" +
                "Generated by Task_Snapshot $SnapshotVersion`r`n`r`n" +
                "此檔案包含 Configs 資料夾下所有設定檔，以及匯出的排程器 XML。`r`n`r`n"
Set-Content -Path $CombinedConfigFile -Value $ConfigHeader -Encoding UTF8

# 2.1 讀取 Configs 資料夾內的檔案
$ConfigFiles = Get-ChildItem -Path "$SourceDir\Configs" -File
foreach ($File in $ConfigFiles) {
    $FileBlock = "`r`n######################################################################`r`n" +
                 "FILE: $($File.Name)`r`n" +
                 "TYPE: Configuration File`r`n" +
                 "######################################################################`r`n`r`n"
    Add-Content -Path $CombinedConfigFile -Value $FileBlock -Encoding UTF8
    
    if (Test-Path $File.FullName) {
        $Content = Get-Content -Path $File.FullName -Raw
        Add-Content -Path $CombinedConfigFile -Value $Content -Encoding UTF8
    }
}

# 2.2 匯出排程器 XML 並讀取內容
$TasksToExport = @("Auto_1Remote_Master", "Auto_BetterGI_Payload")
foreach ($TaskName in $TasksToExport) {
    try {
        $TaskInfo = Get-ScheduledTask -TaskName $TaskName -ErrorAction SilentlyContinue
        if ($TaskInfo) {
            # 匯出到暫存檔
            $TempXmlPath = Join-Path $TempDir "$TaskName.xml"
            Export-ScheduledTask -TaskName $TaskName | Out-File -FilePath $TempXmlPath -Encoding UTF8
            
            # 讀取暫存檔內容寫入合併檔
            $FileBlock = "`r`n######################################################################`r`n" +
                         "FILE: $TaskName.xml`r`n" +
                         "TYPE: Task Scheduler Export`r`n" +
                         "######################################################################`r`n`r`n"
            Add-Content -Path $CombinedConfigFile -Value $FileBlock -Encoding UTF8
            
            $XmlContent = Get-Content -Path $TempXmlPath -Raw
            Add-Content -Path $CombinedConfigFile -Value $XmlContent -Encoding UTF8
            
            # 清理暫存檔
            Remove-Item -Path $TempXmlPath -Force
            Write-Host "    已匯出並合併排程器: $TaskName" -ForegroundColor Gray
        } else {
            Write-Warning "    找不到排程器: $TaskName"
        }
    } catch {
        Write-Warning "    匯出排程器失敗: $TaskName ($($_.Exception.Message))"
    }
}

# ==============================================================================
# 3. 日誌摘要與智能截斷 (Smart Logs Summary)
# ==============================================================================
Write-Host " -> 3/4 正在生成日誌摘要..."

function Get-RecentLogs {
    param ( [string]$Path )
    if (Test-Path $Path) {
        return Get-ChildItem -Path $Path -Filter "*.log" | Sort-Object LastWriteTime -Descending | Select-Object -First 2
    }
    return $null
}

function Get-RecentRemoteLogs {
    param ( [string]$Path )
    if (Test-Path $Path) {
        # 1Remote 的日誌通常是 .md 格式
        return Get-ChildItem -Path $Path -Filter "*.md" | Sort-Object LastWriteTime -Descending | Select-Object -First 2
    }
    return $null
}

function Get-SmartLogContent {
    param ( [string]$FilePath )
    
    $FileInfo = Get-Item $FilePath
    $LimitSize = 2MB
    
    if ($FileInfo.Length -gt $LimitSize) {
        # 大於 2MB，執行截斷
        $Content = Get-Content -Path $FilePath -Tail 5000 -Raw # 讀取最後約 5000 行作為近似
        # 再次檢查大小，若仍過大則只取字元
        if ($Content.Length -gt $LimitSize) {
            $Content = $Content.Substring($Content.Length - $LimitSize)
        }
        return "[TRUNCATED] 此日誌過大 ($([math]::Round($FileInfo.Length/1MB, 2)) MB)，僅顯示末尾 2MB 內容...`r`n`r`n" + $Content
    } else {
        # 小於 2MB，完整讀取
        return Get-Content -Path $FilePath -Raw
    }
}

$LogsDir = "$SourceDir\Logs"
$RemoteLogsDir = "$SourceDir\1Remote\Log"
$BetterGILogsDir = "$SourceDir\Logs\BetterGI"

$LogsOutFile = Join-Path $TempLogs "Recent_Logs_Summary.txt"
Set-Content -Path $LogsOutFile -Value "=== [ Recent Logs Summary (Last 24h + Fallback) ] ===`r`n" -Encoding UTF8

$LogTargets = @()
$LogTargets += Get-RecentLogs -Path $LogsDir
$LogTargets += Get-RecentRemoteLogs -Path $RemoteLogsDir
$LogTargets += Get-RecentLogs -Path $BetterGILogsDir

foreach ($File in $LogTargets) {
    if ($null -eq $File) { continue }
    
    $Header = "`r`n======================================================================`r`n" +
              "FILE: $($File.Name)`r`n" +
              "PATH: $($File.FullName)`r`n" +
              "TIME: $($File.LastWriteTime)`r`n" +
              "SIZE: $([math]::Round($File.Length / 1MB, 2)) MB`r`n" +
              "======================================================================`r`n"
    Add-Content -Path $LogsOutFile -Value $Header -Encoding UTF8
    
    # 使用智能截取函數
    $Content = Get-SmartLogContent -FilePath $File.FullName
    $Content | Out-File -FilePath $LogsOutFile -Append -Encoding UTF8
}

# ==============================================================================
# 4. 壓縮與清理
# ==============================================================================
Write-Host " -> 4/4 正在壓縮打包..."
Compress-Archive -Path "$TempDir\*" -DestinationPath $ZipPath -Force
Remove-Item -Path $TempDir -Recurse -Force

Write-Host "`r`n[完成] 快照已儲存至: $ZipPath" -ForegroundColor Green
Start-Process "explorer.exe" -ArgumentList "/select,`"$ZipPath`""