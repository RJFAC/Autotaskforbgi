<#
.SYNOPSIS
    AutoTask Snapshot Tool V2.14 (Smart Log Filter)
    用於打包所有腳本、設定檔與最近日誌，供 AI 進行除錯分析。
    V2.14:
    1. [Logic] 引入智慧日誌過濾機制：
       - 初始讀取擴大至 200KB。
       - 過濾掉無用的 [DBG] 訊息，但保留包含錯誤關鍵字的 Debug 行。
       - 最終輸出限制在 50KB 以內，確保 AI 能讀取到更高密度的關鍵資訊。
    V2.13: 
    1. [Optimization] 將日誌擷取上限從 2MB 下修至 50KB。
    V2.12: 
    1. 修正 BetterGI 日誌路徑。
    2. 新增 Global Trap 防閃退。
#>

$SnapshotVersion = "V2.14"
$SourceDir = "C:\AutoTask"
$OutputDir = "C:\AutoTask_Snapshots"
$Timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
$ZipName = "AutoTask_Snapshot_$Timestamp.zip"
$ZipPath = Join-Path $OutputDir $ZipName

# --- [防閃退機制] ---
trap {
    Write-Host "`n[CRITICAL ERROR] 發生嚴重錯誤：" -ForegroundColor Red
    Write-Host $_.Exception.Message -ForegroundColor Red
    Write-Host "位置: $($_.InvocationInfo.ScriptLineNumber) 行" -ForegroundColor Red
    Read-Host "按 Enter 鍵退出..."
    exit 1
}

# 核心分析文件路徑
$CoreDocPath = "$SourceDir\Scripts\AutoTask_Core_Analysis.md"
if (-not (Test-Path $CoreDocPath)) { $CoreDocPath = "$SourceDir\AutoTask_Core_Analysis.md" }

# 建立暫存目錄結構
$TempDir = Join-Path $OutputDir "Temp_$Timestamp"
$TempSource = Join-Path $TempDir "1_Source_Code"
$TempConfigs = Join-Path $TempDir "2_Configs"
$TempLogs = Join-Path $TempDir "3_Logs_Summary"

New-Item -ItemType Directory -Path $TempSource -Force | Out-Null
New-Item -ItemType Directory -Path $TempConfigs -Force | Out-Null
New-Item -ItemType Directory -Path $TempLogs -Force | Out-Null

Write-Host "=== AutoTask Snapshot Tool $SnapshotVersion ===" -ForegroundColor Cyan
Write-Host "正在準備快照包..."

# ==============================================================================
# 1. 原始碼合併
# ==============================================================================
Write-Host " -> 1/4 正在合併原始碼..."
$CombinedSourceFile = Join-Path $TempSource "All_Source_Combined.txt"
$SourceHeader = "=== [ AutoTask Full Source Code Dump ] ===`r`nGenerated by Task_Snapshot $SnapshotVersion`r`n`r`n"
Set-Content -Path $CombinedSourceFile -Value $SourceHeader -Encoding UTF8

if (Test-Path $CoreDocPath) {
    $DocBlock = "`r`n######################################################################`r`nFILE: AutoTask_Core_Analysis.md`r`nTYPE: Core Logic Documentation`r`n######################################################################`r`n`r`n"
    Add-Content -Path $CombinedSourceFile -Value $DocBlock -Encoding UTF8
    Add-Content -Path $CombinedSourceFile -Value (Get-Content $CoreDocPath -Raw) -Encoding UTF8
}

$SourceFiles = @()
$SourceFiles += Get-ChildItem -Path $SourceDir -Filter "*.bat" -File
$SourceFiles += Get-ChildItem -Path "$SourceDir\Scripts" -Filter "*.ps1" -File

foreach ($File in $SourceFiles) {
    if ($File.FullName -eq $CoreDocPath) { continue }
    $FileBlock = "`r`n######################################################################`r`nFILE: $($File.Name)`r`nPATH: $($File.FullName)`r`n######################################################################`r`n`r`n"
    Add-Content -Path $CombinedSourceFile -Value $FileBlock -Encoding UTF8
    if (Test-Path $File.FullName) { Add-Content -Path $CombinedSourceFile -Value (Get-Content $File.FullName -Raw) -Encoding UTF8 }
}

# ==============================================================================
# 2. 設定檔合併
# ==============================================================================
Write-Host " -> 2/4 正在合併設定檔..."
$CombinedConfigFile = Join-Path $TempConfigs "All_Configs_Combined.txt"
Set-Content -Path $CombinedConfigFile -Value "=== [ AutoTask Configs ] ===`r`n" -Encoding UTF8

$ConfigFiles = Get-ChildItem -Path "$SourceDir\Configs" -File
foreach ($File in $ConfigFiles) {
    $FileBlock = "`r`n######################################################################`r`nFILE: $($File.Name)`r`n######################################################################`r`n`r`n"
    Add-Content -Path $CombinedConfigFile -Value $FileBlock -Encoding UTF8
    if (Test-Path $File.FullName) { Add-Content -Path $CombinedConfigFile -Value (Get-Content $File.FullName -Raw) -Encoding UTF8 }
}

# 匯出排程器 XML
$TasksToExport = @("Auto_1Remote_Master", "Auto_BetterGI_Payload")
foreach ($TaskName in $TasksToExport) {
    try {
        $TaskInfo = Get-ScheduledTask -TaskName $TaskName -ErrorAction SilentlyContinue
        if ($TaskInfo) {
            $TempXmlPath = Join-Path $TempDir "$TaskName.xml"
            Export-ScheduledTask -TaskName $TaskName | Out-File -FilePath $TempXmlPath -Encoding UTF8
            $FileBlock = "`r`n######################################################################`r`nFILE: $TaskName.xml`r`n######################################################################`r`n`r`n"
            Add-Content -Path $CombinedConfigFile -Value $FileBlock -Encoding UTF8
            Add-Content -Path $CombinedConfigFile -Value (Get-Content $TempXmlPath -Raw) -Encoding UTF8
            Remove-Item -Path $TempXmlPath -Force
        }
    } catch {
        Write-Warning "匯出排程 $TaskName 失敗: $($_.Exception.Message)"
    }
}

# ==============================================================================
# 3. 日誌摘要 (V2.14 智慧過濾版)
# ==============================================================================
Write-Host " -> 3/4 正在生成日誌摘要..."

function Get-SmartLogContent {
    param ( [string]$FilePath )
    try {
        $FileInfo = Get-Item $FilePath
        
        # 1. 初始讀取範圍設定
        # ReadBytes: 200KB (先抓取較大範圍以利過濾，約等於 8000 行)
        # OutputLimit: 50KB (最終交給 AI 的最大長度，約 2000 行)
        $ReadBytes = 204800 
        $OutputLimit = 51200 
        
        # 使用 FileStream 以 ReadOnly 模式開啟，避免鎖定
        $Stream = [System.IO.File]::Open($FilePath, [System.IO.FileMode]::Open, [System.IO.FileAccess]::Read, [System.IO.FileShare]::ReadWrite)
        
        $StartPos = 0
        if ($Stream.Length -gt $ReadBytes) {
            $StartPos = $Stream.Length - $ReadBytes
        }
        
        $null = $Stream.Seek($StartPos, [System.IO.SeekOrigin]::Begin)
        $Reader = New-Object System.IO.StreamReader($Stream)
        $Content = $Reader.ReadToEnd()
        $Reader.Close(); $Stream.Close()

        # 2. 內容過濾邏輯 (Noise Reduction)
        # 如果內容超過輸出限制，嘗試過濾掉 [DBG] 雜訊
        if ($Content.Length -gt $OutputLimit) {
            # 將內容分割為陣列進行處理
            $Lines = $Content -split "`r?`n"
            $FilteredLines = @()
            
            foreach ($Line in $Lines) {
                # 邏輯: 
                # 1. 保留所有非 [DBG] 行 (包含 INF, WRN, ERR, FATAL)
                # 2. 若是 [DBG] 行，僅保留含有關鍵錯誤字眼的行 (防止 Debug 級別的 StackTrace 被誤刪)
                if ($Line -notmatch "\[DBG\]" -or $Line -match "Exception" -or $Line -match "Error" -or $Line -match "Fail" -or $Line -match "Stack Trace" -or $Line -match "Fatal") {
                    $FilteredLines += $Line
                }
            }
            # 重新組合成字串
            $Content = $FilteredLines -join "`r`n"
            
            # 3. 二次裁切 (Final Trim)
            # 如果過濾後仍然過大，則取最後的 OutputLimit 部分
            if ($Content.Length -gt $OutputLimit) {
                $Content = "[...Smart Filtered & Truncated...]`r`n" + $Content.Substring($Content.Length - $OutputLimit)
            } else {
                $Content = "[...Smart Filtered (No Truncation needed)...]`r`n" + $Content
            }
        }

        return $Content
    } catch {
        return "[ERROR READ LOG] $($_.Exception.Message)"
    }
}

$LogsDir = "$SourceDir\Logs"
$RemoteLogsDir = "$SourceDir\1Remote\Log"
$BetterGILogsDir = "C:\Program Files\BetterGI\log"

$LogsOutFile = Join-Path $TempLogs "Recent_Logs_Summary.txt"
Set-Content -Path $LogsOutFile -Value "=== [ Recent Logs Summary (Smart Filter Active) ] ===`r`n" -Encoding UTF8

$LogTargets = @()
if (Test-Path $LogsDir) { $LogTargets += Get-ChildItem -Path $LogsDir -Filter "*.log" | Sort LastWriteTime -Desc | Select -First 2 }
if (Test-Path $RemoteLogsDir) { $LogTargets += Get-ChildItem -Path $RemoteLogsDir -Filter "*.md" | Sort LastWriteTime -Desc | Select -First 2 }
if (Test-Path $BetterGILogsDir) { 
    $LogTargets += Get-ChildItem -Path $BetterGILogsDir -Filter "*.log" | Sort LastWriteTime -Desc | Select -First 2 
} else {
    Write-Warning "找不到 BetterGI 日誌目錄: $BetterGILogsDir"
}

foreach ($File in $LogTargets) {
    if ($null -eq $File) { continue }
    $Header = "`r`n======================================================================`r`nFILE: $($File.Name)`r`nPATH: $($File.FullName)`r`nSIZE: $([math]::Round($File.Length / 1MB, 2)) MB`r`n======================================================================`r`n"
    Add-Content -Path $LogsOutFile -Value $Header -Encoding UTF8
    $Content = Get-SmartLogContent -FilePath $File.FullName
    $Content | Out-File -FilePath $LogsOutFile -Append -Encoding UTF8
}

# ==============================================================================
# 4. 壓縮
# ==============================================================================
Write-Host " -> 4/4 正在壓縮打包..."
try {
    Compress-Archive -Path "$TempDir\*" -DestinationPath $ZipPath -Force -ErrorAction Stop
} catch {
    Write-Host "壓縮失敗！可能原因：檔案被鎖定或權限不足。" -ForegroundColor Red
    Write-Host "錯誤訊息: $($_.Exception.Message)" -ForegroundColor Red
    Read-Host "按 Enter 鍵退出..."
    exit 1
}

Remove-Item -Path $TempDir -Recurse -Force
Write-Host "`r`n[完成] 快照已儲存至: $ZipPath" -ForegroundColor Green

# 這裡加入 Read-Host 防止視窗立刻關閉
Read-Host "作業完成。按 Enter 鍵關閉視窗..."
Start-Process "explorer.exe" -ArgumentList "/select,`"$ZipPath`""