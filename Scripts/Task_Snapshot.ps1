<#
.SYNOPSIS
    AutoTask Snapshot Tool V2.12 (Debug & Fix Path)
    用於打包所有腳本、設定檔與最近日誌，供 AI 進行除錯分析。
    V2.12: 
    1. 修正 BetterGI 日誌路徑為 "C:\Program Files\BetterGI\log"。
    2. 新增 Global Trap 與 Read-Host，確保程式發生錯誤時不會閃退，讓使用者能閱讀紅字。
    3. [Fix] 修正視窗開啟順序，確保 explorer 先執行。
#>

$SnapshotVersion = "V2.12"
$SourceDir = "C:\AutoTask"
$OutputDir = "C:\AutoTask_Snapshots"
$Timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
$ZipName = "AutoTask_Snapshot_$Timestamp.zip"
$ZipPath = Join-Path $OutputDir $ZipName

# --- [防閃退機制] ---
trap {
    Write-Host "`n[CRITICAL ERROR] 發生嚴重錯誤：" -ForegroundColor Red
    Write-Host $_.Exception.Message -ForegroundColor Red
    Write-Host "位置: $($_.InvocationInfo.ScriptLineNumber) 行" -ForegroundColor Red
    Read-Host "按 Enter 鍵退出..."
    exit 1
}

# 核心分析文件路徑
$CoreDocPath = "$SourceDir\Scripts\AutoTask_Core_Analysis.md"
if (-not (Test-Path $CoreDocPath)) { $CoreDocPath = "$SourceDir\AutoTask_Core_Analysis.md" }

# 建立暫存目錄結構
$TempDir = Join-Path $OutputDir "Temp_$Timestamp"
$TempSource = Join-Path $TempDir "1_Source_Code"
$TempConfigs = Join-Path $TempDir "2_Configs"
$TempLogs = Join-Path $TempDir "3_Logs_Summary"

New-Item -ItemType Directory -Path $TempSource -Force | Out-Null
New-Item -ItemType Directory -Path $TempConfigs -Force | Out-Null
New-Item -ItemType Directory -Path $TempLogs -Force | Out-Null

Write-Host "=== AutoTask Snapshot Tool $SnapshotVersion ===" -ForegroundColor Cyan
Write-Host "正在準備快照包..."

# ==============================================================================
# 1. 原始碼合併
# ==============================================================================
Write-Host " -> 1/4 正在合併原始碼..."
$CombinedSourceFile = Join-Path $TempSource "All_Source_Combined.txt"
$SourceHeader = "=== [ AutoTask Full Source Code Dump ] ===`r`nGenerated by Task_Snapshot $SnapshotVersion`r`n`r`n"
Set-Content -Path $CombinedSourceFile -Value $SourceHeader -Encoding UTF8

if (Test-Path $CoreDocPath) {
    $DocBlock = "`r`n######################################################################`r`nFILE: AutoTask_Core_Analysis.md`r`nTYPE: Core Logic Documentation`r`n######################################################################`r`n`r`n"
    Add-Content -Path $CombinedSourceFile -Value $DocBlock -Encoding UTF8
    Add-Content -Path $CombinedSourceFile -Value (Get-Content $CoreDocPath -Raw) -Encoding UTF8
}

$SourceFiles = @()
$SourceFiles += Get-ChildItem -Path $SourceDir -Filter "*.bat" -File
$SourceFiles += Get-ChildItem -Path "$SourceDir\Scripts" -Filter "*.ps1" -File

foreach ($File in $SourceFiles) {
    if ($File.FullName -eq $CoreDocPath) { continue }
    $FileBlock = "`r`n######################################################################`r`nFILE: $($File.Name)`r`nPATH: $($File.FullName)`r`n######################################################################`r`n`r`n"
    Add-Content -Path $CombinedSourceFile -Value $FileBlock -Encoding UTF8
    if (Test-Path $File.FullName) { Add-Content -Path $CombinedSourceFile -Value (Get-Content $File.FullName -Raw) -Encoding UTF8 }
}

# ==============================================================================
# 2. 設定檔合併
# ==============================================================================
Write-Host " -> 2/4 正在合併設定檔..."
$CombinedConfigFile = Join-Path $TempConfigs "All_Configs_Combined.txt"
Set-Content -Path $CombinedConfigFile -Value "=== [ AutoTask Configs ] ===`r`n" -Encoding UTF8

$ConfigFiles = Get-ChildItem -Path "$SourceDir\Configs" -File
foreach ($File in $ConfigFiles) {
    $FileBlock = "`r`n######################################################################`r`nFILE: $($File.Name)`r`n######################################################################`r`n`r`n"
    Add-Content -Path $CombinedConfigFile -Value $FileBlock -Encoding UTF8
    if (Test-Path $File.FullName) { Add-Content -Path $CombinedConfigFile -Value (Get-Content $File.FullName -Raw) -Encoding UTF8 }
}

# 匯出排程器 XML
$TasksToExport = @("Auto_1Remote_Master", "Auto_BetterGI_Payload")
foreach ($TaskName in $TasksToExport) {
    try {
        $TaskInfo = Get-ScheduledTask -TaskName $TaskName -ErrorAction SilentlyContinue
        if ($TaskInfo) {
            $TempXmlPath = Join-Path $TempDir "$TaskName.xml"
            Export-ScheduledTask -TaskName $TaskName | Out-File -FilePath $TempXmlPath -Encoding UTF8
            $FileBlock = "`r`n######################################################################`r`nFILE: $TaskName.xml`r`n######################################################################`r`n`r`n"
            Add-Content -Path $CombinedConfigFile -Value $FileBlock -Encoding UTF8
            Add-Content -Path $CombinedConfigFile -Value (Get-Content $TempXmlPath -Raw) -Encoding UTF8
            Remove-Item -Path $TempXmlPath -Force
        }
    } catch {
        Write-Warning "匯出排程 $TaskName 失敗: $($_.Exception.Message)"
    }
}

# ==============================================================================
# 3. 日誌摘要
# ==============================================================================
Write-Host " -> 3/4 正在生成日誌摘要..."

function Get-SmartLogContent {
    param ( [string]$FilePath )
    try {
        $FileInfo = Get-Item $FilePath
        # 使用 FileStream 以 ReadOnly 模式開啟，避免鎖定錯誤
        $Stream = [System.IO.File]::Open($FilePath, [System.IO.FileMode]::Open, [System.IO.FileAccess]::Read, [System.IO.FileShare]::ReadWrite)
        $Reader = New-Object System.IO.StreamReader($Stream)
        $Content = $Reader.ReadToEnd()
        $Reader.Close(); $Stream.Close()

        if ($Content.Length -gt 2MB) {
            $Content = $Content.Substring($Content.Length - 2MB)
            return "[TRUNCATED] ...`r`n`r`n" + $Content
        }
        return $Content
    } catch {
        return "[ERROR READ LOG] $($_.Exception.Message)"
    }
}

$LogsDir = "$SourceDir\Logs"
$RemoteLogsDir = "$SourceDir\1Remote\Log"
# [V2.12 Fix] 更新 BetterGI 日誌路徑為 "log" (小寫)
$BetterGILogsDir = "C:\Program Files\BetterGI\log"

$LogsOutFile = Join-Path $TempLogs "Recent_Logs_Summary.txt"
Set-Content -Path $LogsOutFile -Value "=== [ Recent Logs Summary ] ===`r`n" -Encoding UTF8

$LogTargets = @()
if (Test-Path $LogsDir) { $LogTargets += Get-ChildItem -Path $LogsDir -Filter "*.log" | Sort LastWriteTime -Desc | Select -First 2 }
if (Test-Path $RemoteLogsDir) { $LogTargets += Get-ChildItem -Path $RemoteLogsDir -Filter "*.md" | Sort LastWriteTime -Desc | Select -First 2 }
if (Test-Path $BetterGILogsDir) { 
    $LogTargets += Get-ChildItem -Path $BetterGILogsDir -Filter "*.log" | Sort LastWriteTime -Desc | Select -First 2 
} else {
    Write-Warning "找不到 BetterGI 日誌目錄: $BetterGILogsDir"
}

foreach ($File in $LogTargets) {
    if ($null -eq $File) { continue }
    $Header = "`r`n======================================================================`r`nFILE: $($File.Name)`r`nPATH: $($File.FullName)`r`nSIZE: $([math]::Round($File.Length / 1MB, 2)) MB`r`n======================================================================`r`n"
    Add-Content -Path $LogsOutFile -Value $Header -Encoding UTF8
    $Content = Get-SmartLogContent -FilePath $File.FullName
    $Content | Out-File -FilePath $LogsOutFile -Append -Encoding UTF8
}

# ==============================================================================
# 4. 壓縮
# ==============================================================================
Write-Host " -> 4/4 正在壓縮打包..."
try {
    Compress-Archive -Path "$TempDir\*" -DestinationPath $ZipPath -Force -ErrorAction Stop
} catch {
    Write-Host "壓縮失敗！可能原因：檔案被鎖定或權限不足。" -ForegroundColor Red
    Write-Host "錯誤訊息: $($_.Exception.Message)" -ForegroundColor Red
    Read-Host "按 Enter 鍵退出..."
    exit 1
}

Remove-Item -Path $TempDir -Recurse -Force
Write-Host "`r`n[完成] 快照已儲存至: $ZipPath" -ForegroundColor Green

# [Fix] 修正順序：先打開檔案總管，再暫停等待
# 使用 /select 參數可以直接選取該檔案，而不僅僅是打開資料夾
Start-Process "explorer.exe" -ArgumentList "/select,`"$ZipPath`""

# 這裡加入 Read-Host 防止視窗立刻關閉，讓使用者有時間看到綠色成功訊息
Read-Host "作業完成。按 Enter 鍵關閉視窗..."