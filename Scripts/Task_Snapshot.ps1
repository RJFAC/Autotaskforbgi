<#
    .SYNOPSIS
    AutoTask Snapshot Generator V2.5 (Smart Log Size Edition)
    .DESCRIPTION
    蒐集系統關鍵檔案、腳本與日誌，打包成 Zip 供 AI 分析或備份。
    
    V2.5 Update (2025-12-09):
    - [Log] 閾值優化: 檔案大小 < 2MB 的日誌將「完整保留」，不再強制截斷。
    - [Log] 巨型保護: 僅針對 > 2MB 的檔案執行 (Head 500 + Tail 2000) 智能截斷。
    - [Merge] 核心功能: 將所有 .ps1 和 .bat 合併為單一文字檔 (All_Source_Combined.txt)。
    - [Source] 完整捕獲: 強制擷取 Scripts 下所有 .ps1 與根目錄下所有 .bat。
#>

$ErrorActionPreference = "SilentlyContinue"

# --- [路徑設定] ---
$WorkDir = "C:\AutoTask"
$ScriptsDir = "$WorkDir\Scripts"
$LogsDir = "$WorkDir\Logs"
$ConfigsDir = "$WorkDir\Configs"
$RemoteLogsDir = "$WorkDir\1Remote\.logs"
$BetterGILogsDir = "C:\Program Files\BetterGI\log"

# 產生時間戳記
$DateStr = Get-Date -Format "yyyyMMdd_HHmmss"
$SnapshotName = "AutoTask_Snapshot_$DateStr"
$TempDir = "$WorkDir\Snapshot_Temp_$DateStr"
$ZipPath = "$WorkDir\$SnapshotName.zip"

# 建立暫存目錄結構
New-Item -ItemType Directory -Path "$TempDir\1_Source_Code" -Force | Out-Null
New-Item -ItemType Directory -Path "$TempDir\2_Configs" -Force | Out-Null
New-Item -ItemType Directory -Path "$TempDir\3_Logs_Summary" -Force | Out-Null

Write-Host "=== AutoTask Snapshot Generator V2.5 ===" -ForegroundColor Cyan
Write-Host "正在建立快照: $SnapshotName" -ForegroundColor Gray

# ==============================================================================
# 1. 核心腳本合併 (The Merger) - 這是 AI 讀取代碼的關鍵
# ==============================================================================
Write-Host " -> 1/4 正在合併原始碼 (All_Source_Combined.txt)..."

$CombinedFile = "$TempDir\1_Source_Code\All_Source_Combined.txt"
Add-Content -Path $CombinedFile -Value "=== [ AutoTask Full Source Code Dump ] ===`r`n" -Encoding UTF8
Add-Content -Path $CombinedFile -Value "Generated by Task_Snapshot V2.5`r`n" -Encoding UTF8
Add-Content -Path $CombinedFile -Value "此檔案包含所有 .bat 與 .ps1 的完整內容，供 AI 一次性讀取。`r`n" -Encoding UTF8

# 定義合併函數
function Append-FileContent {
    param ($FileObj)
    $Header = "`r`n`r`n" + 
              "######################################################################`r`n" +
              "FILE: $($FileObj.Name)`r`n" +
              "PATH: $($FileObj.FullName)`r`n" +
              "######################################################################`r`n"
    Add-Content -Path $CombinedFile -Value $Header -Encoding UTF8
    
    # 讀取並寫入內容 (使用 -Raw 防止截斷)
    $Content = Get-Content -Path $FileObj.FullName -Raw -Encoding UTF8
    Add-Content -Path $CombinedFile -Value $Content -Encoding UTF8
}

# A. 處理根目錄下的 .bat 檔案
Get-ChildItem -Path $WorkDir -Filter "*.bat" | ForEach-Object {
    Write-Host "    Processing: $($_.Name)" -ForegroundColor DarkGray
    Append-FileContent -FileObj $_
    # 同時複製原始檔備份
    Copy-Item -Path $_.FullName -Destination "$TempDir\1_Source_Code" -Force
}

# B. 處理 Scripts 目錄下的 .ps1 檔案
Get-ChildItem -Path $ScriptsDir -Filter "*.ps1" | ForEach-Object {
    Write-Host "    Processing: $($_.Name)" -ForegroundColor DarkGray
    Append-FileContent -FileObj $_
    # 同時複製原始檔備份
    Copy-Item -Path $_.FullName -Destination "$TempDir\1_Source_Code" -Force
}

# ==============================================================================
# 2. 設定檔 (完整複製)
# ==============================================================================
Write-Host " -> 2/4 正在備份設定檔..."
Copy-Item "$ConfigsDir\*.json" -Destination "$TempDir\2_Configs" -Force
Copy-Item "$ConfigsDir\*.map" -Destination "$TempDir\2_Configs" -Force
Copy-Item "$ConfigsDir\*.log" -Destination "$TempDir\2_Configs" -Force
Copy-Item "$WorkDir\0_File_Structure.txt" -Destination "$TempDir" -Force

# ==============================================================================
# 3. 日誌檔案 (智能截斷: <2MB 完整保留)
# ==============================================================================
Write-Host " -> 3/4 正在處理日誌 (智能大小判斷)..."

# 定義智能讀取函數 (僅用於 Log)
function Get-SmartLogContent {
    param ( [string]$FilePath )
    try {
        $FileItem = Get-Item $FilePath
        # 策略 1: 如果檔案小於 2MB，直接完整讀取 (保留全部上下文)
        if ($FileItem.Length -le 2MB) {
            return (Get-Content $FilePath -Raw -Encoding UTF8)
        }

        # 策略 2: 如果大於 2MB，則執行截斷 (Head 500 + Tail 2000)
        $TotalLines = (Get-Content $FilePath).Count
        if ($TotalLines -le 2500) {
            return (Get-Content $FilePath -Raw -Encoding UTF8)
        } else {
            $Head = Get-Content $FilePath -Head 500 -Encoding UTF8
            $Tail = Get-Content $FilePath -Tail 2000 -Encoding UTF8
            return ($Head + "`r`n... (省略中間 $($TotalLines - 2500) 行) ...`r`n" + $Tail) | Out-String
        }
    } catch {
        return "Error reading file: $($_.Exception.Message)"
    }
}

function Get-RecentLogs {
    param ($Path)
    if (-not (Test-Path $Path)) { return @() }
    $Logs = Get-ChildItem -Path "$Path\*.log" | Where-Object { $_.LastWriteTime -ge (Get-Date).AddHours(-24) } | Sort-Object LastWriteTime -Descending
    if ($Logs.Count -eq 0) {
        $Logs = Get-ChildItem -Path "$Path\*.log" | Sort-Object LastWriteTime -Descending | Select-Object -First 1
    }
    return $Logs
}

function Get-RecentRemoteLogs {
    param ($Path)
    if (-not (Test-Path $Path)) { return @() }
    $Logs = Get-ChildItem -Path "$Path\*.md" | Where-Object { $_.LastWriteTime -ge (Get-Date).AddHours(-24) } | Sort-Object LastWriteTime -Descending
    if ($Logs.Count -eq 0) {
        $Logs = Get-ChildItem -Path "$Path\*.md" | Sort-Object LastWriteTime -Descending | Select-Object -First 1
    }
    return $Logs
}

$LogsOutFile = "$TempDir\3_Logs_Summary\Recent_Logs_Summary.txt"
Add-Content -Path $LogsOutFile -Value "=== [ Recent Logs Summary (Last 24h + Fallback) ] ===`r`n" -Encoding UTF8

$LogTargets = @()
$LogTargets += Get-RecentLogs -Path $LogsDir
$LogTargets += Get-RecentRemoteLogs -Path $RemoteLogsDir
$LogTargets += Get-RecentLogs -Path $BetterGILogsDir

foreach ($File in $LogTargets) {
    if ($null -eq $File) { continue }
    
    $Header = "`r`n======================================================================`r`n" +
              "FILE: $($File.Name)`r`n" +
              "PATH: $($File.FullName)`r`n" +
              "TIME: $($File.LastWriteTime)`r`n" +
              "SIZE: $([math]::Round($File.Length / 1MB, 2)) MB`r`n" +
              "======================================================================`r`n"
    Add-Content -Path $LogsOutFile -Value $Header -Encoding UTF8
    $Content = Get-SmartLogContent -FilePath $File.FullName
    $Content | Out-File -FilePath $LogsOutFile -Append -Encoding UTF8
}

# ==============================================================================
# 4. 壓縮與清理
# ==============================================================================
Write-Host " -> 4/4 正在壓縮打包..."
Compress-Archive -Path "$TempDir\*" -DestinationPath $ZipPath -Force
Remove-Item -Path $TempDir -Recurse -Force

Write-Host "`r`n[完成] 快照已儲存至: $ZipPath" -ForegroundColor Green
Write-Host "ZIP 內已包含 'All_Source_Combined.txt'，且小於 2MB 的日誌已完整保留。" -ForegroundColor Yellow

if ($Host.Name -eq "ConsoleHost") { Start-Sleep -Seconds 3 }