<#
    .SYNOPSIS
    AutoTask Snapshot Generator V2.6 (Combined Only Edition)
    .DESCRIPTION
    蒐集系統關鍵檔案、腳本與日誌，打包成 Zip 供 AI 分析或備份。
    
    V2.6 Update (2025-12-09):
    - [Optimize] 精簡化: 不再複製個別的 .ps1/.bat 檔案，避免檔案數量過多。
    - [Source] 單一來源: 僅生成 All_Source_Combined.txt 作為唯一的代碼來源。
    - [Log] 保持 V2.5 的智能截斷 (<2MB 保留, >2MB 截斷)。
#>

$ErrorActionPreference = "SilentlyContinue"

# --- [路徑設定] ---
$WorkDir = "C:\AutoTask"
$ScriptsDir = "$WorkDir\Scripts"
$LogsDir = "$WorkDir\Logs"
$ConfigsDir = "$WorkDir\Configs"
$RemoteLogsDir = "$WorkDir\1Remote\.logs"
$BetterGILogsDir = "C:\Program Files\BetterGI\log"

# 產生時間戳記
$DateStr = Get-Date -Format "yyyyMMdd_HHmmss"
$SnapshotName = "AutoTask_Snapshot_$DateStr"
$TempDir = "$WorkDir\Snapshot_Temp_$DateStr"
$ZipPath = "$WorkDir\$SnapshotName.zip"

# 建立暫存目錄結構
New-Item -ItemType Directory -Path "$TempDir\1_Source_Code" -Force | Out-Null
New-Item -ItemType Directory -Path "$TempDir\2_Configs" -Force | Out-Null
New-Item -ItemType Directory -Path "$TempDir\3_Logs_Summary" -Force | Out-Null

Write-Host "=== AutoTask Snapshot Generator V2.6 ===" -ForegroundColor Cyan
Write-Host "正在建立快照: $SnapshotName" -ForegroundColor Gray

# ==============================================================================
# 1. 核心腳本合併 (The Merger) - 這是 AI 讀取代碼的關鍵
# ==============================================================================
Write-Host " -> 1/4 正在合併原始碼 (All_Source_Combined.txt)..."

$CombinedFile = "$TempDir\1_Source_Code\All_Source_Combined.txt"
Add-Content -Path $CombinedFile -Value "=== [ AutoTask Full Source Code Dump ] ===`r`n" -Encoding UTF8
Add-Content -Path $CombinedFile -Value "Generated by Task_Snapshot V2.6`r`n" -Encoding UTF8
Add-Content -Path $CombinedFile -Value "此檔案包含所有 .bat 與 .ps1 的完整內容，供 AI 一次性讀取。`r`n" -Encoding UTF8
Add-Content -Path $CombinedFile -Value "注意：個別腳本檔案已不再包含於此快照包中。`r`n" -Encoding UTF8

# 定義合併函數
function Append-FileContent {
    param ($FileObj)
    $Header = "`r`n`r`n" + 
              "######################################################################`r`n" +
              "FILE: $($FileObj.Name)`r`n" +
              "PATH: $($FileObj.FullName)`r`n" +
              "######################################################################`r`n"
    Add-Content -Path $CombinedFile -Value $Header -Encoding UTF8
    
    # 讀取並寫入內容 (使用 -Raw 防止截斷)
    $Content = Get-Content -Path $FileObj.FullName -Raw -Encoding UTF8
    Add-Content -Path $CombinedFile -Value $Content -Encoding UTF8
}

# A. 處理根目錄下的 .bat 檔案
Get-ChildItem -Path $WorkDir -Filter "*.bat" | ForEach-Object {
    Write-Host "    Processing: $($_.Name)" -ForegroundColor DarkGray
    Append-FileContent -FileObj $_
    # V2.6: 不再複製個別檔案，僅合併
}

# B. 處理 Scripts 目錄下的 .ps1 檔案
Get-ChildItem -Path $ScriptsDir -Filter "*.ps1" | ForEach-Object {
    Write-Host "    Processing: $($_.Name)" -ForegroundColor DarkGray
    Append-FileContent -FileObj $_
    # V2.6: 不再複製個別檔案，僅合併
}

# ==============================================================================
# 2. 設定檔 (完整複製)
# ==============================================================================
Write-Host " -> 2/4 正在備份設定檔..."
Copy-Item "$ConfigsDir\*.json" -Destination "$TempDir\2_Configs" -Force
Copy-Item "$ConfigsDir\*.map" -Destination "$TempDir\2_Configs" -Force
Copy-Item "$ConfigsDir\*.log" -Destination "$TempDir\2_Configs" -Force
Copy-Item "$WorkDir\0_File_Structure.txt" -Destination "$TempDir" -Force

# ==============================================================================
# 3. 日誌檔案 (智能截斷: <2MB 完整保留)
# ==============================================================================
Write-Host " -> 3/4 正在處理日誌 (智能大小判斷)..."

# 定義智能讀取函數 (僅用於 Log)
function Get-SmartLogContent {
    param ( [string]$FilePath )
    try {
        $FileItem = Get-Item $FilePath
        # 策略 1: 如果檔案小於 2MB，直接完整讀取 (保留全部上下文)
        if ($FileItem.Length -le 2MB) {
            return (Get-Content $FilePath -Raw -Encoding UTF8)
        }

        # 策略 2: 如果大於 2MB，則執行截斷 (Head 500 + Tail 2000)
        $TotalLines = (Get-Content $FilePath).Count
        if ($TotalLines -le 2500) {
            return (Get-Content $FilePath -Raw -Encoding UTF8)
        } else {
            $Head = Get-Content $FilePath -Head 500 -Encoding UTF8
            $Tail = Get-Content $FilePath -Tail 2000 -Encoding UTF8
            return ($Head + "`r`n... (省略中間 $($TotalLines - 2500) 行) ...`r`n" + $Tail) | Out-String
        }
    } catch {
        return "Error reading file: $($_.Exception.Message)"
    }
}

function Get-RecentLogs {
    param ($Path)
    if (-not (Test-Path $Path)) { return @() }
    $Logs = Get-ChildItem -Path "$Path\*.log" | Where-Object { $_.LastWriteTime -ge (Get-Date).AddHours(-24) } | Sort-Object LastWriteTime -Descending
    if ($Logs.Count -eq 0) {
        $Logs = Get-ChildItem -Path "$Path\*.log" | Sort-Object LastWriteTime -Descending | Select-Object -First 1
    }
    return $Logs
}

function Get-RecentRemoteLogs {
    param ($Path)
    if (-not (Test-Path $Path)) { return @() }
    $Logs = Get-ChildItem -Path "$Path\*.md" | Where-Object { $_.LastWriteTime -ge (Get-Date).AddHours(-24) } | Sort-Object LastWriteTime -Descending
    if ($Logs.Count -eq 0) {
        $Logs = Get-ChildItem -Path "$Path\*.md" | Sort-Object LastWriteTime -Descending | Select-Object -First 1
    }
    return $Logs
}

$LogsOutFile = "$TempDir\3_Logs_Summary\Recent_Logs_Summary.txt"
Add-Content -Path $LogsOutFile -Value "=== [ Recent Logs Summary (Last 24h + Fallback) ] ===`r`n" -Encoding UTF8

$LogTargets = @()
$LogTargets += Get-RecentLogs -Path $LogsDir
$LogTargets += Get-RecentRemoteLogs -Path $RemoteLogsDir
$LogTargets += Get-RecentLogs -Path $BetterGILogsDir

foreach ($File in $LogTargets) {
    if ($null -eq $File) { continue }
    
    $Header = "`r`n======================================================================`r`n" +
              "FILE: $($File.Name)`r`n" +
              "PATH: $($File.FullName)`r`n" +
              "TIME: $($File.LastWriteTime)`r`n" +
              "SIZE: $([math]::Round($File.Length / 1MB, 2)) MB`r`n" +
              "======================================================================`r`n"
    Add-Content -Path $LogsOutFile -Value $Header -Encoding UTF8
    $Content = Get-SmartLogContent -FilePath $File.FullName
    $Content | Out-File -FilePath $LogsOutFile -Append -Encoding UTF8
}

# ==============================================================================
# 4. 壓縮與清理
# ==============================================================================
Write-Host " -> 4/4 正在壓縮打包..."
Compress-Archive -Path "$TempDir\*" -DestinationPath $ZipPath -Force
Remove-Item -Path $TempDir -Recurse -Force

Write-Host "`r`n[完成] 快照已儲存至: $ZipPath" -ForegroundColor Green
Write-Host "ZIP 僅包含合併後的 'All_Source_Combined.txt' 與日誌，檔案已大幅精簡。" -ForegroundColor Yellow

if ($Host.Name -eq "ConsoleHost") { Start-Sleep -Seconds 3 }