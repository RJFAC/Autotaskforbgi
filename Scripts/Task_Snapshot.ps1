<#
.SYNOPSIS
    AutoTask AI Context Pack Generator V3.4
    專為 "上傳給 AI 進行開發與除錯" 設計的快照工具。
    
    V3.4 Fixes:
    1. [Path] 修正文件搜尋邏輯，增加對 "Scripts" 目錄的掃描，解決找不到 SSOT 的問題。
    
    V3.3 Fixes:
    1. [Syntax] 全面修復 PowerShell 解析錯誤 (Regex 引號, &, }).
    2. [Compat] 確保使用 [System.Math] 相容 PS 5.1。
#>

$SnapshotVersion = "V3.4 (AI Context Pack)"
$SourceDir = "C:\AutoTask"
$OutputDir = "C:\AutoTask_Snapshots"
$Timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
$ZipName = "AutoTask_AI_Context_$Timestamp.zip"
$ZipPath = Join-Path $OutputDir $ZipName

# 獲取當前環境敏感資訊 (用於脫敏)
$SensitiveUser = [System.Environment]::UserName
$SensitiveMachine = [System.Environment]::MachineName

# --- [防閃退機制] ---
trap {
    Write-Host "`n[CRITICAL ERROR] 發生嚴重錯誤：" -ForegroundColor Red
    Write-Host $_.Exception.Message -ForegroundColor Red
    Write-Host "位置: $($_.InvocationInfo.ScriptLineNumber) 行" -ForegroundColor Red
    Read-Host "按 Enter 鍵退出..."
    exit 1
}

# 建立暫存目錄結構
$TempDir = Join-Path $OutputDir "Temp_$Timestamp"
$TempDocs = Join-Path $TempDir "00_Documentation"
$TempSource = Join-Path $TempDir "01_Source_Code"
$TempConfigs = Join-Path $TempDir "02_Configs_Sanitized"
$TempLogs = Join-Path $TempDir "03_Logs_Summary"

New-Item -ItemType Directory -Path $TempDocs -Force | Out-Null
New-Item -ItemType Directory -Path $TempSource -Force | Out-Null
New-Item -ItemType Directory -Path $TempConfigs -Force | Out-Null
New-Item -ItemType Directory -Path $TempLogs -Force | Out-Null

Write-Host "=== AutoTask AI Context Pack Generator $SnapshotVersion ===" -ForegroundColor Cyan
Write-Host "正在準備 AI 上下文包..."

# ==============================================================================
# 1. 文件聚合 (Documentation)
# ==============================================================================
Write-Host " -> 1/5 收集系統文件 (SSOT/Manual)..."
# 定義關鍵文件名稱模式
$DocPatterns = @("AutoTask_System_SSOT*", "SSOT_Maintenance*", "Developer_Manual*", "AutoTask_Core_Analysis*")
# 定義搜尋路徑: 根目錄 + Scripts 目錄
$DocSearchPaths = @($SourceDir, "$SourceDir\Scripts")
$FoundDocs = $false

foreach ($Path in $DocSearchPaths) {
    if (Test-Path $Path) {
        foreach ($Pattern in $DocPatterns) {
            $Files = Get-ChildItem -Path $Path -Filter "$Pattern.txt" -ErrorAction SilentlyContinue
            $Files += Get-ChildItem -Path $Path -Filter "$Pattern.md" -ErrorAction SilentlyContinue
            foreach ($File in $Files) {
                # 避免重複複製 (若根目錄與 Scripts 都有)
                $DestPath = Join-Path $TempDocs $File.Name
                if (-not (Test-Path $DestPath)) {
                    Copy-Item -Path $File.FullName -Destination $TempDocs -Force
                    Write-Host "    + 包含: $($File.Name)" -ForegroundColor Green
                    $FoundDocs = $true
                }
            }
        }
    }
}

if (-not $FoundDocs) {
    Write-Host "    [提示] 未在根目錄或 Scripts 目錄找到 SSOT 文件。" -ForegroundColor Yellow
    Set-Content -Path "$TempDocs\READ_ME.txt" -Value "SSOT files not found." -Encoding UTF8
}

# ==============================================================================
# 2. 原始碼合併 (Source Code)
# ==============================================================================
Write-Host " -> 2/5 合併原始碼..."
$CombinedSourceFile = Join-Path $TempSource "All_Source_Combined.txt"
$SourceHeader = "=== [ AutoTask Full Source Code Dump ] ===`r`nGenerated by Task_Snapshot $SnapshotVersion`r`n`r`n"
Set-Content -Path $CombinedSourceFile -Value $SourceHeader -Encoding UTF8

$SourceFiles = @()
$SourceFiles += Get-ChildItem -Path $SourceDir -Filter "*.bat" -File
$SourceFiles += Get-ChildItem -Path "$SourceDir\Scripts" -Filter "*.ps1" -File

foreach ($File in $SourceFiles) {
    $FileBlock = "`r`n######################################################################`r`nFILE: $($File.Name)`r`nPATH: $($File.FullName)`r`n######################################################################`r`n`r`n"
    Add-Content -Path $CombinedSourceFile -Value $FileBlock -Encoding UTF8
    if (Test-Path $File.FullName) { Add-Content -Path $CombinedSourceFile -Value (Get-Content $File.FullName -Raw) -Encoding UTF8 }
}

# ==============================================================================
# 3. 設定檔匯出與脫敏 (Configs Sanitization)
# ==============================================================================
Write-Host " -> 3/5 匯出設定檔並執行脫敏 (Privacy Scrub)..."
$CombinedConfigFile = Join-Path $TempConfigs "All_Configs_Sanitized.txt"
Set-Content -Path $CombinedConfigFile -Value "=== [ AutoTask Configs (Sanitized) ] ===`r`nNOTE: Real Usernames and Machine IDs have been replaced.`r`n`r`n" -Encoding UTF8

# 輔助函式：脫敏處理
function Sanitize-Content {
    param ([string]$Content)
    if ([string]::IsNullOrWhiteSpace($Content)) { return "" }
    
    # 替換使用者名稱
    $Content = $Content -replace [regex]::Escape($SensitiveUser), "User"
    # 替換機器名稱
    $Content = $Content -replace [regex]::Escape($SensitiveMachine), "LOCALHOST"
    
    # 使用單引號定義 Regex，避免 PowerShell 解析錯誤
    $Pattern = 'C:\\Users\\[^\\]+'
    $Content = $Content -replace $Pattern, "%USERPROFILE%"
    
    return $Content
} 

# 處理一般 Configs
$ConfigFiles = Get-ChildItem -Path "$SourceDir\Configs" -File
foreach ($File in $ConfigFiles) {
    $FileBlock = "`r`n######################################################################`r`nFILE: $($File.Name)`r`n######################################################################`r`n`r`n"
    Add-Content -Path $CombinedConfigFile -Value $FileBlock -Encoding UTF8
    if (Test-Path $File.FullName) { 
        $RawContent = Get-Content $File.FullName -Raw -Encoding UTF8
        $CleanContent = Sanitize-Content $RawContent
        Add-Content -Path $CombinedConfigFile -Value $CleanContent -Encoding UTF8 
    }
}

# 匯出並脫敏排程器 XML
$TasksToExport = @("Auto_1Remote_Master", "Auto_BetterGI_Payload")
foreach ($TaskName in $TasksToExport) {
    try {
        $TaskInfo = Get-ScheduledTask -TaskName $TaskName -ErrorAction SilentlyContinue
        if ($TaskInfo) {
            $TempXmlPath = Join-Path $TempDir "$TaskName.xml"
            Export-ScheduledTask -TaskName $TaskName | Out-File -FilePath $TempXmlPath -Encoding UTF8
            
            $FileBlock = "`r`n######################################################################`r`nFILE: $TaskName.xml`r`n######################################################################`r`n`r`n"
            Add-Content -Path $CombinedConfigFile -Value $FileBlock -Encoding UTF8
            
            $RawXml = Get-Content $TempXmlPath -Raw
            $CleanXml = Sanitize-Content $RawXml
            Add-Content -Path $CombinedConfigFile -Value $CleanXml -Encoding UTF8
            
            Remove-Item -Path $TempXmlPath -Force
        }
    } catch {
        Write-Warning "匯出排程 $TaskName 失敗"
    }
}

# ==============================================================================
# 4. 智慧日誌過濾 (Smart Logs)
# ==============================================================================
Write-Host " -> 4/5 生成智慧日誌摘要..."

function Get-SmartLogContent {
    param ( [string]$FilePath )
    try {
        $FileInfo = Get-Item $FilePath
        $ReadBytes = 204800 
        $OutputLimit = 51200 
        
        $Stream = [System.IO.File]::Open($FilePath, [System.IO.FileMode]::Open, [System.IO.FileAccess]::Read, [System.IO.FileShare]::ReadWrite)
        $StartPos = 0
        if ($Stream.Length -gt $ReadBytes) { $StartPos = $Stream.Length - $ReadBytes }
        $null = $Stream.Seek($StartPos, [System.IO.SeekOrigin]::Begin)
        $Reader = New-Object System.IO.StreamReader($Stream)
        $Content = $Reader.ReadToEnd()
        $Reader.Close(); $Stream.Close()

        $Content = Sanitize-Content $Content

        if ($Content.Length -gt $OutputLimit) {
            $Lines = $Content -split "`r?`n"
            $FilteredLines = @()
            foreach ($Line in $Lines) {
                if ($Line -notmatch "\[DBG\]" -or $Line -match "Exception" -or $Line -match "Error" -or $Line -match "Fail" -or $Line -match "Stack Trace" -or $Line -match "Fatal") {
                    $FilteredLines += $Line
                }
            }
            $Content = $FilteredLines -join "`r`n"
            
            if ($Content.Length -gt $OutputLimit) {
                $Content = "[...Smart Filtered and Truncated...]`r`n" + $Content.Substring($Content.Length - $OutputLimit)
            }
        }
        return $Content
    } catch {
        return "[ERROR READ LOG] $($_.Exception.Message)"
    }
}

$LogsDir = "$SourceDir\Logs"
$RemoteLogsDir = "$SourceDir\1Remote\Log"
$BetterGILogsDir = "C:\Program Files\BetterGI\log"
$LogsOutFile = Join-Path $TempLogs "Recent_Logs_Summary.txt"
Set-Content -Path $LogsOutFile -Value "=== [ Recent Logs Summary ] ===`r`n" -Encoding UTF8

$LogTargets = @()
if (Test-Path $LogsDir) { $LogTargets += Get-ChildItem -Path $LogsDir -Filter "*.log" | Sort LastWriteTime -Desc | Select -First 2 }
if (Test-Path $RemoteLogsDir) { $LogTargets += Get-ChildItem -Path $RemoteLogsDir -Filter "*.md" | Sort LastWriteTime -Desc | Select -First 2 }
if (Test-Path $BetterGILogsDir) { $LogTargets += Get-ChildItem -Path $BetterGILogsDir -Filter "*.log" | Sort LastWriteTime -Desc | Select -First 2 }

foreach ($File in $LogTargets) {
    if ($null -eq $File) { continue }
    # 確保使用 [System.Math]
    $SizeMB = [System.Math]::Round($File.Length / 1MB, 2)
    $Header = "`r`n======================================================================`r`nFILE: $($File.Name)`r`nPATH: $($File.FullName)`r`nSIZE: $SizeMB MB`r`n======================================================================`r`n"
    Add-Content -Path $LogsOutFile -Value $Header -Encoding UTF8
    $Content = Get-SmartLogContent -FilePath $File.FullName
    $Content | Out-File -FilePath $LogsOutFile -Append -Encoding UTF8
}

# ==============================================================================
# 5. 壓縮打包
# ==============================================================================
Write-Host " -> 5/5 壓縮打包..."
try {
    Compress-Archive -Path "$TempDir\*" -DestinationPath $ZipPath -Force -ErrorAction Stop
} catch {
    Write-Host "壓縮失敗: $($_.Exception.Message)" -ForegroundColor Red
    Read-Host "按 Enter 鍵退出..."
    exit 1
}

Remove-Item -Path $TempDir -Recurse -Force
Write-Host "`r`n[完成] Context Pack 已儲存至: $ZipPath" -ForegroundColor Green
Write-Host "⚠️ 注意: 已執行基本脫敏，但上傳前仍建議檢查內容。" -ForegroundColor Yellow

Read-Host "作業完成。按 Enter 鍵關閉視窗..."
Invoke-Item $ZipPath